#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class DocumentType:
  """
  Les types de documents qui peuvent etre retournes par l'Indexer
  """
  ARTIST = 1
  ALBUM = 2

  _VALUES_TO_NAMES = {
    1: "ARTIST",
    2: "ALBUM",
  }

  _NAMES_TO_VALUES = {
    "ARTIST": 1,
    "ALBUM": 2,
  }

class NodeType:
  """
  Les type de noeud dans l'arbre syntaxique de la requete.
  """
  OPERATOR = 1
  LITERAL = 2

  _VALUES_TO_NAMES = {
    1: "OPERATOR",
    2: "LITERAL",
  }

  _NAMES_TO_VALUES = {
    "OPERATOR": 1,
    "LITERAL": 2,
  }


class Artist:
  """
  Un artiste qui fait de la musique.
  Pensez a Justin Bieber.

  Attributes:
   - id: L'identifiant unique pour cet artiste
   - name: Le nom sous lequel l'artiste est connu
   - origin: Le pays d'origine de l'artiste
   - active_start: La date a laquelle l'artiste a commence a etre actif
  La date est du format yyyy-MM-dd'T'HH:mm:ssZZZ
  Voir la documentation pour plus d'information sur les formats de date
   - active_end: La date a laquelle l'artiste a cesse d'etre actif
  La date est du format yyyy-MM-dd'T'HH:mm:ssZZZ
  Voir la documentation pour plus d'information sur les formats de date
   - genres: Les genre musicaux de cet artiste
   - labels: Les maisons de disque sous lesquelles cet artiste publie
   - albums: Les identifiants uniques des albums de cet artiste
   - group_names: Le nom des groupes dont cet artiste est membre
   - instruments_played: Les instruments que cet artiste joue
   - text: La description de cet artiste.
  La description est extraite de Wikipedia et contient de la
  syntaxe Mediawiki http://www.mediawiki.org/wiki/Help:Formatting
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'id', None, None, ), # 1
    (2, TType.SET, 'name', (TType.STRING,None), None, ), # 2
    (3, TType.SET, 'origin', (TType.STRING,None), None, ), # 3
    (4, TType.SET, 'active_start', (TType.STRING,None), None, ), # 4
    (5, TType.SET, 'active_end', (TType.STRING,None), None, ), # 5
    (6, TType.SET, 'genres', (TType.STRING,None), None, ), # 6
    (7, TType.SET, 'labels', (TType.STRING,None), None, ), # 7
    (8, TType.SET, 'albums', (TType.STRING,None), None, ), # 8
    (9, TType.SET, 'group_names', (TType.STRING,None), None, ), # 9
    (10, TType.SET, 'instruments_played', (TType.STRING,None), None, ), # 10
    (11, TType.STRING, 'text', None, None, ), # 11
  )

  def __init__(self, id=None, name=None, origin=None, active_start=None, active_end=None, genres=None, labels=None, albums=None, group_names=None, instruments_played=None, text=None,):
    self.id = id
    self.name = name
    self.origin = origin
    self.active_start = active_start
    self.active_end = active_end
    self.genres = genres
    self.labels = labels
    self.albums = albums
    self.group_names = group_names
    self.instruments_played = instruments_played
    self.text = text

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.name = set()
          (_etype3, _size0) = iprot.readSetBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString();
            self.name.add(_elem5)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.origin = set()
          (_etype9, _size6) = iprot.readSetBegin()
          for _i10 in xrange(_size6):
            _elem11 = iprot.readString();
            self.origin.add(_elem11)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.SET:
          self.active_start = set()
          (_etype15, _size12) = iprot.readSetBegin()
          for _i16 in xrange(_size12):
            _elem17 = iprot.readString();
            self.active_start.add(_elem17)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.SET:
          self.active_end = set()
          (_etype21, _size18) = iprot.readSetBegin()
          for _i22 in xrange(_size18):
            _elem23 = iprot.readString();
            self.active_end.add(_elem23)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.SET:
          self.genres = set()
          (_etype27, _size24) = iprot.readSetBegin()
          for _i28 in xrange(_size24):
            _elem29 = iprot.readString();
            self.genres.add(_elem29)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.labels = set()
          (_etype33, _size30) = iprot.readSetBegin()
          for _i34 in xrange(_size30):
            _elem35 = iprot.readString();
            self.labels.add(_elem35)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.SET:
          self.albums = set()
          (_etype39, _size36) = iprot.readSetBegin()
          for _i40 in xrange(_size36):
            _elem41 = iprot.readString();
            self.albums.add(_elem41)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.SET:
          self.group_names = set()
          (_etype45, _size42) = iprot.readSetBegin()
          for _i46 in xrange(_size42):
            _elem47 = iprot.readString();
            self.group_names.add(_elem47)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.SET:
          self.instruments_played = set()
          (_etype51, _size48) = iprot.readSetBegin()
          for _i52 in xrange(_size48):
            _elem53 = iprot.readString();
            self.instruments_played.add(_elem53)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.text = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Artist')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.SET, 2)
      oprot.writeSetBegin(TType.STRING, len(self.name))
      for iter54 in self.name:
        oprot.writeString(iter54)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.origin is not None:
      oprot.writeFieldBegin('origin', TType.SET, 3)
      oprot.writeSetBegin(TType.STRING, len(self.origin))
      for iter55 in self.origin:
        oprot.writeString(iter55)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.active_start is not None:
      oprot.writeFieldBegin('active_start', TType.SET, 4)
      oprot.writeSetBegin(TType.STRING, len(self.active_start))
      for iter56 in self.active_start:
        oprot.writeString(iter56)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.active_end is not None:
      oprot.writeFieldBegin('active_end', TType.SET, 5)
      oprot.writeSetBegin(TType.STRING, len(self.active_end))
      for iter57 in self.active_end:
        oprot.writeString(iter57)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.genres is not None:
      oprot.writeFieldBegin('genres', TType.SET, 6)
      oprot.writeSetBegin(TType.STRING, len(self.genres))
      for iter58 in self.genres:
        oprot.writeString(iter58)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.labels is not None:
      oprot.writeFieldBegin('labels', TType.SET, 7)
      oprot.writeSetBegin(TType.STRING, len(self.labels))
      for iter59 in self.labels:
        oprot.writeString(iter59)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.albums is not None:
      oprot.writeFieldBegin('albums', TType.SET, 8)
      oprot.writeSetBegin(TType.STRING, len(self.albums))
      for iter60 in self.albums:
        oprot.writeString(iter60)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.group_names is not None:
      oprot.writeFieldBegin('group_names', TType.SET, 9)
      oprot.writeSetBegin(TType.STRING, len(self.group_names))
      for iter61 in self.group_names:
        oprot.writeString(iter61)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.instruments_played is not None:
      oprot.writeFieldBegin('instruments_played', TType.SET, 10)
      oprot.writeSetBegin(TType.STRING, len(self.instruments_played))
      for iter62 in self.instruments_played:
        oprot.writeString(iter62)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 11)
      oprot.writeString(self.text)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Album:
  """
  Un album de musique qui contient des chansons.
  Pensez .. au dernier album de Justin Bieber.

  Attributes:
   - id: L'identifiant unique de cet album
   - name: Le nom de cet album
   - artists: Les identifiants uniques des artistes qui ont produit cet album
   - release_date: La date a laquelle cet album a ete lance
  La date est du format yyyy-MM-dd'T'HH:mm:ssZZZ
  Voir la documentation pour plus d'information sur les formats de date
   - genres: Les genre musicaux de cet album
   - track_names: Les titres des chansons sur cet album
   - text: La description de cet album.
  La description est extraite de Wikipedia et contient de la
  syntaxe Mediawiki http://www.mediawiki.org/wiki/Help:Formatting
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'id', None, None, ), # 1
    (2, TType.SET, 'name', (TType.STRING,None), None, ), # 2
    (3, TType.SET, 'artists', (TType.STRING,None), None, ), # 3
    (4, TType.SET, 'release_date', (TType.STRING,None), None, ), # 4
    (5, TType.SET, 'genres', (TType.STRING,None), None, ), # 5
    (6, TType.SET, 'track_names', (TType.STRING,None), None, ), # 6
    (7, TType.STRING, 'text', None, None, ), # 7
  )

  def __init__(self, id=None, name=None, artists=None, release_date=None, genres=None, track_names=None, text=None,):
    self.id = id
    self.name = name
    self.artists = artists
    self.release_date = release_date
    self.genres = genres
    self.track_names = track_names
    self.text = text

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.name = set()
          (_etype66, _size63) = iprot.readSetBegin()
          for _i67 in xrange(_size63):
            _elem68 = iprot.readString();
            self.name.add(_elem68)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.artists = set()
          (_etype72, _size69) = iprot.readSetBegin()
          for _i73 in xrange(_size69):
            _elem74 = iprot.readString();
            self.artists.add(_elem74)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.SET:
          self.release_date = set()
          (_etype78, _size75) = iprot.readSetBegin()
          for _i79 in xrange(_size75):
            _elem80 = iprot.readString();
            self.release_date.add(_elem80)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.SET:
          self.genres = set()
          (_etype84, _size81) = iprot.readSetBegin()
          for _i85 in xrange(_size81):
            _elem86 = iprot.readString();
            self.genres.add(_elem86)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.SET:
          self.track_names = set()
          (_etype90, _size87) = iprot.readSetBegin()
          for _i91 in xrange(_size87):
            _elem92 = iprot.readString();
            self.track_names.add(_elem92)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.text = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Album')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.SET, 2)
      oprot.writeSetBegin(TType.STRING, len(self.name))
      for iter93 in self.name:
        oprot.writeString(iter93)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.artists is not None:
      oprot.writeFieldBegin('artists', TType.SET, 3)
      oprot.writeSetBegin(TType.STRING, len(self.artists))
      for iter94 in self.artists:
        oprot.writeString(iter94)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.release_date is not None:
      oprot.writeFieldBegin('release_date', TType.SET, 4)
      oprot.writeSetBegin(TType.STRING, len(self.release_date))
      for iter95 in self.release_date:
        oprot.writeString(iter95)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.genres is not None:
      oprot.writeFieldBegin('genres', TType.SET, 5)
      oprot.writeSetBegin(TType.STRING, len(self.genres))
      for iter96 in self.genres:
        oprot.writeString(iter96)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.track_names is not None:
      oprot.writeFieldBegin('track_names', TType.SET, 6)
      oprot.writeSetBegin(TType.STRING, len(self.track_names))
      for iter97 in self.track_names:
        oprot.writeString(iter97)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 7)
      oprot.writeString(self.text)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FacetFilter:
  """
  Filtre sur une facette. Vous devez uniquement retourner des resultats qui, pour les metadata
  fournis contiennent une des valeurs fournies. Voir la documentation pour plus d'information.

  Attributes:
   - metadataName: Le nom du metadata sur lequel le filtre s'applique.
   - values: Les valeurs acceptees pour ce metadata.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'metadataName', None, None, ), # 1
    (2, TType.LIST, 'values', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, metadataName=None, values=None,):
    self.metadataName = metadataName
    self.values = values

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.metadataName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.values = []
          (_etype101, _size98) = iprot.readListBegin()
          for _i102 in xrange(_size98):
            _elem103 = iprot.readString();
            self.values.append(_elem103)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FacetFilter')
    if self.metadataName is not None:
      oprot.writeFieldBegin('metadataName', TType.STRING, 1)
      oprot.writeString(self.metadataName)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.values))
      for iter104 in self.values:
        oprot.writeString(iter104)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueryTreeNode:
  """
  Represente un noeud dans l'arbre syntaxique de la requete.

  Voir la documentation pour des exemples.

  Attributes:
   - value: La valeur du noeud.

  Par exemple, un noeud dont le type est "OPERATOR" pourrait avoir la valeur "OR",
  "AND" ou "NOT". Un noeud dont le type est "LITERAL" pourrait avoir la valeur "Justin Bieber".
   - type: Le type du noeud. Le type influence ce que sera contenu dans "value", "leftPart" et "rightPart".
  Voir la documentation pour plus d'information et des exemples.
   - leftPart: L'identifiant du noeud representant la partie de gauche de la requete. Si la valeur est -1, il n'y a pas de partie de gauche.
   - rightPart: L'identifiant du noeud representant la partie de droite de la requete. Si la valeur est -1, il n'y a pas de partie de droite.
   - id: L'identifiant de ce noeud.
  Est necessairement plus grand que zero.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'value', None, None, ), # 1
    (2, TType.I32, 'type', None, None, ), # 2
    (3, TType.I32, 'leftPart', None, None, ), # 3
    (4, TType.I32, 'rightPart', None, None, ), # 4
    (5, TType.I32, 'id', None, None, ), # 5
  )

  def __init__(self, value=None, type=None, leftPart=None, rightPart=None, id=None,):
    self.value = value
    self.type = type
    self.leftPart = leftPart
    self.rightPart = rightPart
    self.id = id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.leftPart = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.rightPart = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryTreeNode')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 1)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.leftPart is not None:
      oprot.writeFieldBegin('leftPart', TType.I32, 3)
      oprot.writeI32(self.leftPart)
      oprot.writeFieldEnd()
    if self.rightPart is not None:
      oprot.writeFieldBegin('rightPart', TType.I32, 4)
      oprot.writeI32(self.rightPart)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 5)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Query:
  """
  Une "Query" est une requete faite a votre index. Votre index doit repondre de maniere appropriee
  et le plus rapidement possible.

  Voir la documentation du concours pour savoir ce que signifie une reponse "appropriee".

  Attributes:
   - rootId: L'identifiant du noeud racine de l'arbre syntaxique de cette requete.
   - queryTreeNodes: Liste des noeuds composant l'arbre.
   - facetFilters: Liste de filtres sur les facettes
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'rootId', None, None, ), # 1
    (2, TType.LIST, 'queryTreeNodes', (TType.STRUCT,(QueryTreeNode, QueryTreeNode.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'facetFilters', (TType.STRUCT,(FacetFilter, FacetFilter.thrift_spec)), None, ), # 3
  )

  def __init__(self, rootId=None, queryTreeNodes=None, facetFilters=None,):
    self.rootId = rootId
    self.queryTreeNodes = queryTreeNodes
    self.facetFilters = facetFilters

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.rootId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.queryTreeNodes = []
          (_etype108, _size105) = iprot.readListBegin()
          for _i109 in xrange(_size105):
            _elem110 = QueryTreeNode()
            _elem110.read(iprot)
            self.queryTreeNodes.append(_elem110)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.facetFilters = []
          (_etype114, _size111) = iprot.readListBegin()
          for _i115 in xrange(_size111):
            _elem116 = FacetFilter()
            _elem116.read(iprot)
            self.facetFilters.append(_elem116)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Query')
    if self.rootId is not None:
      oprot.writeFieldBegin('rootId', TType.I32, 1)
      oprot.writeI32(self.rootId)
      oprot.writeFieldEnd()
    if self.queryTreeNodes is not None:
      oprot.writeFieldBegin('queryTreeNodes', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.queryTreeNodes))
      for iter117 in self.queryTreeNodes:
        iter117.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.facetFilters is not None:
      oprot.writeFieldBegin('facetFilters', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.facetFilters))
      for iter118 in self.facetFilters:
        iter118.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueryResult:
  """
  Un resultat d'une requete a votre index.
  Les resultats doivent etre retournes dans le bon ordre.
  Un resultat peut etre soit un Artist ou un Album.
  Si documentType est DocumentType.ARTIST, l'identifiant doit etre un identifiant d'artiste.
  Si documentType est DocumentType.ALBUM, l'identifiant doit etre un identifiant d'album.

  Voir la documentation du concours pour savoir ce que signifie "dans le bon ordre".

  Attributes:
   - documentType: Le type du document.
  Si documentType est DocumentType.ARTIST, seul artist doit etre rempli.
  Si documentType est DocumentType.ALBUM, seul album doit etre rempli.
   - id: L'identifiant unique du document tel que fournit lors de l'indexation.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'documentType', None, None, ), # 1
    (2, TType.STRING, 'id', None, None, ), # 2
  )

  def __init__(self, documentType=None, id=None,):
    self.documentType = documentType
    self.id = id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.documentType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.id = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryResult')
    if self.documentType is not None:
      oprot.writeFieldBegin('documentType', TType.I32, 1)
      oprot.writeI32(self.documentType)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 2)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FacetValue:
  """
  Une valeur pour une facet.

  Par exemple, si on a une facet sur le metadata "Auteur", une valeur
  pourrait etre "Nickleback" et un count "42".

  Attributes:
   - value: Une valeur de facet.
   - count: Le nombre de resultats qui ont cette valeur pour ce metadata.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'value', None, None, ), # 1
    (2, TType.I32, 'count', None, None, ), # 2
  )

  def __init__(self, value=None, count=None,):
    self.value = value
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FacetValue')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 1)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I32, 2)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FacetResult:
  """
  Une facet et ses valeurs.

  Attributes:
   - metadataName: Le nom du metadata sur lequel la facet est basee (e.g. "Auteur")
   - values: La liste de valeurs associees a ce metadata (e.g. "Justin Bieber" : 5, "Bob Marley" : 3)
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'metadataName', None, None, ), # 1
    (2, TType.LIST, 'values', (TType.STRUCT,(FacetValue, FacetValue.thrift_spec)), None, ), # 2
  )

  def __init__(self, metadataName=None, values=None,):
    self.metadataName = metadataName
    self.values = values

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.metadataName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.values = []
          (_etype122, _size119) = iprot.readListBegin()
          for _i123 in xrange(_size119):
            _elem124 = FacetValue()
            _elem124.read(iprot)
            self.values.append(_elem124)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FacetResult')
    if self.metadataName is not None:
      oprot.writeFieldBegin('metadataName', TType.STRING, 1)
      oprot.writeString(self.metadataName)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter125 in self.values:
        iter125.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueryResponse:
  """
  Le resultat complet d'une requete a votre index.

  Attributes:
   - facets: Toutes les facets pour les resultats obtenus par la requete.

  Voir la documentation du concours pour plus de details.
   - results: Tous les resultats de la requete.

  Les resultats doivent etre retournes dans le bon ordre.
  Voir la documentation du concours pour plus de details.
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'facets', (TType.STRUCT,(FacetResult, FacetResult.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'results', (TType.STRUCT,(QueryResult, QueryResult.thrift_spec)), None, ), # 2
  )

  def __init__(self, facets=None, results=None,):
    self.facets = facets
    self.results = results

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.facets = []
          (_etype129, _size126) = iprot.readListBegin()
          for _i130 in xrange(_size126):
            _elem131 = FacetResult()
            _elem131.read(iprot)
            self.facets.append(_elem131)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.results = []
          (_etype135, _size132) = iprot.readListBegin()
          for _i136 in xrange(_size132):
            _elem137 = QueryResult()
            _elem137.read(iprot)
            self.results.append(_elem137)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryResponse')
    if self.facets is not None:
      oprot.writeFieldBegin('facets', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.facets))
      for iter138 in self.facets:
        iter138.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.results is not None:
      oprot.writeFieldBegin('results', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.results))
      for iter139 in self.results:
        iter139.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
